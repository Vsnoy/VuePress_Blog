(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{477:function(e,s,t){"use strict";t.r(s);var a=t(14),n=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"react"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" React")]),e._v(" "),t("h2",{attrs:{id:"官方重点语录备忘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#官方重点语录备忘"}},[e._v("#")]),e._v(" 官方重点语录备忘")]),e._v(" "),t("ul",[t("li",[e._v("一个元素的 "),t("code",[e._v("key")]),e._v(" 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 "),t("code",[e._v("id")]),e._v(" 来作为元素的 "),t("code",[e._v("key")]),e._v(" 。当元素没有确定 "),t("code",[e._v("id")]),e._v(" 的时候，万不得已你可以使用元素索引 "),t("code",[e._v("index")]),e._v(" 作为 "),t("code",[e._v("key")]),e._v(" 。")]),e._v(" "),t("li",[e._v("如果列表项目的顺序可能会变化，我们不建议使用索引来用作 "),t("code",[e._v("key")]),e._v(" 值，因为这样做会导致性能变差，还可能引起组件状态的问题。如果你选择不指定显式的 "),t("code",[e._v("key")]),e._v(" 值，那么 React 将默认使用索引用作为列表项目的 "),t("code",[e._v("key")]),e._v(" 值。")]),e._v(" "),t("li",[e._v("数组元素中使用的 "),t("code",[e._v("key")]),e._v(" 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 "),t("code",[e._v("key")]),e._v(" 值。")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/lists-and-keys.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("列表 & Key"),t("OutboundLink")],1)]),e._v(" "),t("hr"),e._v(" "),t("ul",[t("li",[e._v("与 "),t("code",[e._v("class")]),e._v(" 组件中的 "),t("code",[e._v("setState")]),e._v(" 方法不同，"),t("code",[e._v("useState")]),e._v(" 不会自动合并更新对象。")]),e._v(" "),t("li",[e._v("如果你的更新函数返回值与当前 "),t("code",[e._v("state")]),e._v(" 完全相同，则随后的重渲染会被完全跳过。")]),e._v(" "),t("li",[e._v("如果你更新 "),t("code",[e._v("State Hook")]),e._v(" 后的 "),t("code",[e._v("state")]),e._v(" 与当前的 "),t("code",[e._v("state")]),e._v(" 相同时，"),t("code",[e._v("React")]),e._v(" 将跳过子组件的渲染并且不会触发 "),t("code",[e._v("effect")]),e._v(" 的执行。（ "),t("code",[e._v("React")]),e._v(" 使用 "),t("code",[e._v("Object.is")]),e._v(" 比较算法 来比较 "),t("code",[e._v("state")]),e._v(" ）")]),e._v(" "),t("li",[e._v("需要注意的是，"),t("code",[e._v("React")]),e._v(" 可能仍需要在跳过渲染前渲染该组件。不过由于 "),t("code",[e._v("React")]),e._v(" 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 "),t("code",[e._v("useMemo")]),e._v(" 来进行优化。")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hook API 索引之 useState"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"其他重点语录备忘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他重点语录备忘"}},[e._v("#")]),e._v(" 其他重点语录备忘")]),e._v(" "),t("ul",[t("li",[e._v("函数组件的每一帧会有自己独立的 "),t("code",[e._v("state")]),e._v(" 、"),t("code",[e._v("function")]),e._v(" 、"),t("code",[e._v("props")]),e._v("。")]),e._v(" "),t("li",[e._v("如果某些情况下 "),t("code",[e._v("key")]),e._v(" 不起作用（可能是组件初始化的开销太大）")]),e._v(" "),t("li",[t("code",[e._v("React")]),e._v(" 组件中的 "),t("code",[e._v("key")]),e._v(" 属性的值改变，"),t("code",[e._v("React")]),e._v(" 将会创建新的实例，而不是更新现有的实例。")]),e._v(" "),t("li",[t("code",[e._v("React")]),e._v(" 本身执行的过程和代码都是同步的，只是合成事件和生命周期钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，就是我们所说的异步了。")])]),e._v(" "),t("h2",{attrs:{id:"类组件事件绑定-this-的四种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类组件事件绑定-this-的四种方式"}},[e._v("#")]),e._v(" 类组件事件绑定 this 的四种方式")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// constructor 中使用 bind  \nthis.handleClick = this.handleClick.bind(this)\n\n// 定义处使用类变量语法\nhandleClick = () => { ... }\n\n// render 方法中使用 bind\n<button onClick={this.handleClick.bind(this)}> 点击 </button>\n\n// render 方法中使用箭头函数\n<button onClick={() => {this.handleClick()}}> 点击 </button>\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br")]),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);